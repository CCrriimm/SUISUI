name: Validate models and configs

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write

jobs:
  validate:
    runs-on: ubuntu-latest

    steps:
      # Check out the PR so we can diff against the base branch
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Collect all files changed by this PR
      - name: Get changed files
        run: |
          git fetch origin ${{ github.base_ref }}
          git diff --name-only origin/${{ github.base_ref }}...HEAD > changed_files.txt
          cat changed_files.txt

      # Decide whether model and/or config validation is needed
      - name: Detect asset changes
        id: detect
        run: |
          MODELS=false
          CONFIGS=false

          if grep -qE '^models/.*\.onnx$' changed_files.txt; then
            MODELS=true
          fi

          if grep -qE '^configs/.*\.cfg$' changed_files.txt; then
            CONFIGS=true
          fi

          echo "models=$MODELS" >> $GITHUB_OUTPUT
          echo "configs=$CONFIGS" >> $GITHUB_OUTPUT

      # Python and ONNX are only required when validating models
      - name: Set up Python
        if: steps.detect.outputs.models == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install ONNX
        if: steps.detect.outputs.models == 'true'
        run: |
          pip install onnx

      # Validate ONNX structure and YOLOv8/v11 shape contract
      - name: Validate ONNX models
        if: steps.detect.outputs.models == 'true'
        id: model_check
        run: |
          set -e
          python << 'EOF'
          import onnx
          import sys
          import hashlib
          from pathlib import Path

          # Size limits for accepted models
          MIN_SIZE = 5 * 1024 * 1024
          MAX_SIZE = 50 * 1024 * 1024

          # Only validate models added or modified in this PR
          changed = Path("changed_files.txt").read_text().splitlines()
          models = [f for f in changed if f.startswith("models/") and f.endswith(".onnx")]

          if not models:
              print("models directory modified but no .onnx file was added")
              sys.exit(1)

          # Track hashes to prevent duplicate uploads
          hashes_dir = Path(".model_hashes")
          hashes_dir.mkdir(exist_ok=True)
          hash_file = hashes_dir / "hashes.txt"

          existing_hashes = set()
          if hash_file.exists():
              existing_hashes = set(hash_file.read_text().splitlines())

          # Helper to normalize static vs dynamic ONNX dimensions
          def dim(d):
              return d.dim_value if d.dim_value > 0 else None

          new_hashes = []

          for model_path in models:
              path = Path(model_path)

              # Enforce model size bounds
              size = path.stat().st_size
              if size < MIN_SIZE or size > MAX_SIZE:
                  print(f"invalid model size: {path.name}")
                  sys.exit(1)

              # Reject models already present in the repository
              sha = hashlib.sha256(path.read_bytes()).hexdigest()
              if sha in existing_hashes:
                  print(f"duplicate model detected: {path.name}")
                  sys.exit(1)

              model = onnx.load(path)
              graph = model.graph

              # YOLO models must expose a single image input
              if len(graph.input) != 1:
                  print("model must have exactly one input")
                  sys.exit(1)

              inp = graph.input[0]
              in_dims = [dim(d) for d in inp.type.tensor_type.shape.dim]

              # Expect NCHW input, static or dynamic
              if len(in_dims) != 4:
                  print("input must be rank-4 [B,3,H,W]")
                  sys.exit(1)

              if in_dims[1] != 3:
                  print("input must have 3 channels")
                  sys.exit(1)

              # YOLOv8/v11 exports use a single output tensor
              if len(graph.output) != 1:
                  print("model must have exactly one output")
                  sys.exit(1)

              out = graph.output[0]
              out_dims = [dim(d) for d in out.type.tensor_type.shape.dim]

              # Output shape is [B, C+4, N]
              if len(out_dims) != 3:
                  print("output must be rank-3 [B,C+4,N]")
                  sys.exit(1)

              # Require at least bbox + one class
              if out_dims[1] is not None and out_dims[1] < 5:
                  print("output channel count must be >= 5")
                  sys.exit(1)

              new_hashes.append(sha)

          # Persist new model hashes for future duplicate detection
          with open(hash_file, "a") as f:
              for h in new_hashes:
                  f.write(h + "\n")
          EOF

      # Basic sanity checks for config-only PRs
      - name: Validate config files
        if: steps.detect.outputs.configs == 'true'
        id: config_check
        run: |
          set -e
          CFGS=$(grep -E '^configs/.*\.cfg$' changed_files.txt)

          for cfg in $CFGS; do
            # Configs must not be empty
            if [ ! -s "$cfg" ]; then
              echo "empty config file: $cfg"
              exit 1
            fi

            # Configs should reference an ONNX model
            if ! grep -qi '\.onnx' "$cfg"; then
              echo "config does not reference an onnx model: $cfg"
              exit 1
            fi
          done

      # Tag PRs that passed model validation
      - name: Add model validated label
        if: steps.model_check.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['model:validated']
            })

      # Tag PRs that passed config validation
      - name: Add config validated label
        if: steps.config_check.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['config:validated']
            })

      # Leave a short, actionable comment when validation fails
      - name: Comment on validation failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: "Validation failed. Check model size (5â€“50MB), ONNX structure, YOLO output shape [B,C+4,N], and config references."
            })
